- вы предпочтете асинхронное взаимодействие на основе событий, а не синхронные удаленные вызовы.
- взаимодействие на основе событий, а не синхронные удаленные вызовы, и вы будете хранить копии
  одних и тех же данных в нескольких микросервисах, чтобы быть уверенным, что они доступны там, где нужны. Все
  В целом, эти методы значительно снижают необходимость в удаленных вызовах

- dotnet workload install aspire

# Aspire

# Docker Compose

# Kubernetes

- Микросервисы могут использовать три основных стиля взаимодействия: команды, запросы и события.

Кроме того, следует отдавать предпочтение совместной работе на основе событий, а не совместной работе
основанному на командах или запросах. Совместная работа на основе событий является более слабосвязанной
чем две другие формы сотрудничества, потому что события обрабатываются асинхронно.
Это означает, что два микросервиса, взаимодействующие через события, не связаны по времени; обработка события не обязательно должна происходить сразу после его
поднятия. Скорее, обработка может происходить, когда подписчик готов к этому. В отличие от этого, команды и запросы являются синхронными и поэтому должны обрабатываться
сразу после их отправки.

Команды и запросы - это мощные формы совместной работы, но они оба страдают от того, что
синхронности по своей природе. Как уже говорилось, это создает связь между
микросервисами, которые выставляют конечные точки, и микросервисами, которые вызывают конечные точки.
Далее мы обратимся к асинхронному взаимодействию через события.


События: Асинхронная совместная работа
Совместная работа на основе событий является асинхронной. То есть микросервис, который публикует события, не вызывает микросервисы, которые подписываются на эти события. Скорее
подписчики обрабатывают новые события, когда они готовы их обработать. Когда мы используем
HTTP для реализации этого стиля взаимодействия, подписчики опрашивают новые события.
Этот опрос я буду называть подпиской на ленту событий. Хотя опрос производится
из синхронных запросов, сотрудничество является асинхронным, потому что публикация
событий не зависит от опроса подписчиков.

 Как и в случае с другими типами совместной работы, у взаимодействия на основе событий есть две стороны. Одна сторона - это микросервис, который публикует события через канал событий, а
другая - микросервисы, которые подписываются на эти события.


РАСКРЫТИЕ ПОТОКА СОБЫТИЙ
Микросервис может публиковать события для других микросервисов через канал событий, который представляет собой просто
HTTP-конечная точка - например, «/events», - к которой другой микросервис может
делать запросы и получать данные о событиях


# События в очередях
Альтернативой публикации событий через ленту событий является использование технологии очередей,
например, RabbitMQ, AWS SQS или Azure Queue Storage. При таком подходе микросервисы
публикующие события, отправляют их в очередь, а подписчики считывают их из очереди.
очереди. События должны быть направлены от издателя к нескольким подписчикам, и то, как
это зависит от выбора технологии очереди и может потребовать дополнительных
технологий поверх очереди. Как и в случае с подходом, основанным на подаче событий, микросервис
подписывающийся на события, имеет процесс event-subscriber, который считывает события из
очереди и обрабатывает их. Воспроизведение событий также может быть построено на основе очередей, но может
но это может потребовать дополнительной работы в зависимости от технологии очередей.
Это вполне жизнеспособный подход к реализации взаимодействия между микросервисами на основе событий. Но в этой книге для совместной работы на основе событий используются каналы событий на основе HTTP.
потому что они позволяют воспроизводить события в любое время и являются простым, но надежным и
масштабируемое решение.

# События через gRPC

Как уже говорилось, команды и запросы напрямую связаны с удаленными вызовами процедур gRPC.
Но как быть с событиями? В gRPC есть концепция потоковой передачи, которая позволяет держать
HTTP/2 соединение открытым и отправлять данные через него. Потоковая передача в
gRPC работает в обоих направлениях - от клиента к серверу или от сервера к клиенту. Чтобы моделировать
событий с помощью потоковой передачи gRPC, вы можете создать удаленную процедуру, которая работает в некотором роде как лента событий: она позволяет подписчикам событий вызывать процедуру и получать
события обратно в виде ответного потока. 

Существует три типа совместной работы микросервисов:

- Сотрудничество на основе команд, когда один микросервис использует HTTP POST, PUT или DELETE, чтобы заставить другой микросервис выполнить действие.
- Сотрудничество на основе запросов, когда один микросервис использует HTTP GET для запросить состояние другого микросервиса

- Взаимодействие на основе событий, когда один микросервис раскрывает поток событий, на которую могут подписаться другие микросервисы, опрашивая ленту на предмет новых событий.

- Сотрудничество на основе событий является более слабосвязанным, чем сотрудничество на основе команд и запросов.

- Вы можете использовать HttpClient для отправки команд другим микросервисам и для запросов другие микросервисы.

- Вы можете использовать контроллеры MVC, чтобы открыть конечные точки для получения и обработки команд и запросов.

- Контроллер MVC может отображать простую ленту событий.

Вы можете создать процесс, который подписывается на события, создав
- Создание консольного приложения .NET
- Используя HttpClient для чтения событий из ленты событий
- Запустить это приложение как CronJob в Kubernetes




---


Микросервису обычно требуется хранить три типа данных:
 Данные, относящиеся к возможностям, которые реализует микросервис. Это данные, за которые
за которые отвечает микросервис и которые он должен поддерживать в безопасности и актуальности.
 События, вызванные микросервисом. Во время обработки команд микросервису может потребоваться вызвать события, чтобы сообщить остальной части системы об обновлениях
данных, за которые отвечает микросервис.
 Чтение моделей на основе данных в событиях от других микросервисов или иногда
на данных из запросов к другим микросервисам.
Эти три типа данных могут храниться в разных базах данных и даже в разных
типах баз данных. 


---

 В контексте микросервисов, работающих относительно близко друг к другу (например, в пределах
одного центра обработки данных), устранение запросов на информацию, которая уже есть у вызывающей стороны, с помощью
использования заголовков cache-control часто бывает достаточно, чтобы получить желаемые преимущества в скорости и надежности. Необходимость использования ETags для устранения ненужных тел ответов
возникает в ситуациях, когда ответы на запросы велики и поэтому требуют значительной пропускной способности или когда расстояние между микросервисами больше (например, они
они находятся в разных центрах обработки данных или в разных зонах облака).


----


Они должны предоставлять информацию о своем состоянии с помощью протоколирования, должны позволять осуществлять мониторинг и следовать стандартам безопасности.
которые вы определили для системы. Таким образом, создание нового микросервиса подразумевает нечто большее, чем
просто создание нового, пустого проекта ASP.NET.